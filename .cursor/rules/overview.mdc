---
description: 
globs: 
alwaysApply: true
---
# Overview: Multi-Strategy Trading Platform

This server hosts and manages multiple independent trading strategies, each with its own codebase and database. Strategies can be enabled, disabled, and controlled independently. Shared resources such as the exchange API (for opening/closing trades) and technical analysis indicators are available to all strategies.

## Strategy Architecture

Each strategy:
- Lives in its own directory under `src/strategies/`
- Must have a `strategy.json` configuration file with the following schema:
  ```json
  {
    "name": "strategy_name",
    "enabled": true|false,
    "description": "Strategy description",
    "cronSchedule": "cron_schedule_expression"
  }
  ```
- Must have a `run.ts` (or `run.js` in production) file that exports a `runPipelineTask()` function
- Has its own isolated database (for data, signals, logs, etc.)
- Can use shared modules from `src/trading/`, `src/alerts/`, etc.
- Is responsible for its own data ingestion, signal generation, and trade execution logic

## Server Implementation

The server:
- Automatically discovers and loads strategies from the `strategies/` directory
- Validates each strategy's configuration and entry point
- Initializes each enabled strategy by running its pipeline once
- Sets up cron jobs based on each strategy's schedule
- Provides HTTP endpoints for:
  - `/status`: View status of all loaded strategies
  - `/run-pipeline/:strategy`: Manually trigger a strategy's pipeline
- Handles authentication and error recovery

## Current Strategies

### ETHQuake
- Location: `src/strategies/ethquake/`
- Purpose: Forewarns of impending large price movements in ETHUSD by monitoring blockchain activity
- Schedule: Runs every 15 minutes
- Components:
  - Data Collection: Monitors transactions from addresses of interest
  - Signal Generation: Analyzes transaction patterns
  - Trade Execution: Uses EMAs to determine trade direction
  - Maintenance: CLI tools for updating addresses of interest

### EMAs
- Location: `src/strategies/emas/`
- Purpose: Trades based on EMA crossovers
- Schedule: Runs hourly

## Adding New Strategies

To add a new strategy:
1. Create a new directory under `src/strategies/`
2. Add `strategy.json` with required configuration
3. Implement `run.ts` with the `runPipelineTask()` function
4. Strategy will be automatically loaded on next server start

## Shared Infrastructure

Common functionality available to all strategies:
- Trading: Order placement and position management via Kraken API
- Technical Analysis: EMA calculations and other indicators
- Alerts: Notification system for important events
- Database: MongoDB connections (each strategy should use its own database)



# ETHQuake Strategy overview:

ETHQuake forewarns of impending large price movements in ETHUSD.

ETHQuake works by monitoring transactions which involve addresses of interest, that tend to increase activity before large market movements (see Maintenance CLI section for information on maintaining this list of addresses of interest). Our server periodically queries the blockchain to see how many addresses of interest made transactions having a value greater or equal to a given amount (default 100 ETH). We keep track of the number of these transactions per hour (queried every 15 min by default).

The results are made available via our /charts web endpoint, in a simple chart. 

If the number of transactions within a given period cross a given threshold then it will trigger the automated trading component. At the time of writing, we're set up to trigger the trade signal if there are two consecutive hours each having more than 20 transactions. This means that the soonest a trade signall will trigger is if there was a 1 hour period having >= 20 transactions followed by an additional 20 transactions in the next 15min (because we're currently querying every 15 min).

If a trade signal is detected, then we need to determine the direction. This is currently done by checking if moving averages are trending up or down. If there's a trend we proceed, otherwise no action. 

If we proceed then we open a trade for a given amount, with a trailing stop at a given distance (at the time of writing, the trailing stop is set to 4%).

Once a trade opens, we activate a cool-down period (currently 48 hours) during which time no additional trades will be made.

Maintaining and closing of the position is outside the scope of this project.

# Maintenance CLI

Our list of 'addresses_of_interest' is the crucial ingredient. These addresses change over time and must be kept up-to-date.

An update should ideally happen after each large movement, and because this happens infrequently we will trigger this manually via a simple CLI.

The process is as-follows:

1. Identify timestamps where ETHUSD price moved more than n% (done manually, not in scope of this project)
2. Identify random timestamps of normal trading activity, as a control group
3. Identify transactions >= 100 ETH in the hour leading up to each large price movement
4. Identify transactions >= 100 ETH in the hour leading up to each control group timestamp
5. Identify all sending & receiving addresses from step 3, that do NOT appear in any transactions from step 4.

To achieve this, we will maintain two collections in the mongodb
- 'price_movements'
- 'addresses_of_interest'

Our CLI will accept the following commands:
- add-timestamp: accept a new UNIX timestamp as a parameter, and enter it into the 'price_movements' collection. Each document in the collection will include the integer timestamp as entered, and its corresponding date formatted using UTC. Additional fields may be necessary in order to keep track of which price movements have been processed to update the addresses of interest.
- get-new-addresses: This will automate steps 2 to 5 for each new timestamp, and enter any new addresses into the 'addresses_of_interest' collection. Each entry in the collection will contain the address field, and will also keep track of how many transactions this address has appeared in as the receiver and how many as the sender in each price movement window identified in step 1.

Much of the logic to query for transactions has been done previously for manual JSON based processing and we can re-purpose it. Refer to [getPriceMovementTransactions.js](mdc:src/scripts/manual/getPriceMovementTransactions.js) and [adresses_of_interest.js](mdc:src/scripts/manual/adresses_of_interest.js)

## Details for each step:

### 1. Price movement identifaction
I've written a pinescript, @largePriceMovements.pine, and use it to output a list of timestamps on the hourly timeframe, for n% movements

### 2. Transaction Collection leading up to price movement
Here we use thirdweb's insight api, we can adapt the uri:

`https://insight.thirdweb.com/v1/transactions?chain=1&filter_block_timestamp_gte=${start_timestamp}&filter_block_timestamp_lte=${end_timestamp}&sort_by=block_number&sort_order=desc&filter_value_gte=100000000000000000000&limit=200&clientId=${process.env.TW_CLIENT_ID}`

We have implemented the fetchTransactions fn in [getTWTransactions.js](mdc:src/lib/getTWTransactions.js) that can be used for this.

- end_timestamp should be the timestamp picked up in step 1, and start_timestamp should be 1 hour before.
- check references section for the reponse schema

### 3. Transaction Collection for control group
Randomly select an equal number of timestamps to be processed, distributed evenly between the timestamps provided in step 1. These will not be large price movements, and we can assume that these will reveal regualar market activity. Run the same api call to gather all Txs (up to a max of 200) having a value >= 100ETH

### 4. Identify 'addresses of interest'
Identify all addresses in the "to_address" and "from_address" fields of the transactions that appear in our target group that DO NOT appear in our control group. Add these to our mongoDB collection along with their stats mentioned above.

# Notes

## hosting
We're using Railway for our trade and web server.

## database
You can grab the mongodb client at any time from @mongodb.js.

## conventions
- Values like >= 100 ETH are to be considered default values and parameterized.
- Please use imports not require. 
- please don't use semicolons
- please only include helpful explanatory and professional comments in the code itself - no smart remarks or sarcasm.
- ALL dates and times are in UTC.

# references:

## Kraken Futures API documentation:

https://docs.kraken.com/api/docs/websocket-v2/add_order/

## the schema of the response for the insights api call:

`{
  "meta": {
    "page": 0,
    "total_items": 55,
    "limit_per_chain": 200,
    "chain_ids": [
      1
    ]
  },
  "data": [
    {
      "chain_id": "1",
      "hash": "0xac9d970136bc603816e3ea4ed5448c1cfaff8801cbf559ea47fafc8e407f7a36",
      "nonce": 1140679,
      "block_hash": "0xe0f87c388bc5062b5fec9a7cb3b651a4dd5b51104b3d8bb8f2ac09fe8f3d335f",
      "block_number": 19648873,
      "block_timestamp": 1713038303,
      "transaction_index": 137,
      "from_address": "0xbf94f0ac752c739f623c463b5210a7fb2cbb420b",
      "to_address": "0x300226f054150e787a797f1fd07f0e38a4a655f4",
      "value": 5276403336614035000,
      "gas": 210000,
      "gas_price": 265891111695,
      "data": "0x",
      "function_selector": "",
      "max_fee_per_gas": 800000000000,
      "max_priority_fee_per_gas": 2000000000,
      "transaction_type": 2,
      "r": "33204313308798684969966964165828171613369332685451283128705698389927787652781",
      "s": "55404361698948675971047837556325863522582529447941196630929550420470244480677",
      "v": "1",
      "access_list_json": "[]",
      "contract_address": null,
      "gas_used": 21000,
      "cumulative_gas_used": 17429342,
      "effective_gas_price": 265891111695,
      "blob_gas_used": 0,
      "blob_gas_price": 0,
      "logs_bloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
      "status": 1
    },
    {...}
  ]
}`






